     2   beizhang #define MODULE_TITLE "UXDLIB main module"
     2   beizhang /*****************************************************************************
     7   beizhang  * * MODULE:     UXDMAIGX.c
     2   beizhang  * ***************************************************************************
     2   beizhang  * *      AUTHOR:       T. Waltari 12.10.1999
     2   beizhang  * *      REVISED BY:   -
     2   beizhang  * *
     2   beizhang  * *      Copyright (c) 1999 Nokia Networks
     2   beizhang  * ***************************************************************************
     2   beizhang  * *
     2   beizhang  * *      Main module of the UXDLIB library
     2   beizhang  * *
     7   beizhang  * *  Currently supports plug-in units : 
     7   beizhang  * *  CCPC2, CCPC2_A, CCP10, CCP18-A, CCP18-B and CCP18-C, CCP1D_A/B
     2   beizhang  * *  support for MX622,MX622 A, NI4S1 A, SF05 and SF05 A not needed anymore.
     2   beizhang  ******************************************************************************/
     2   beizhang 
     2   beizhang #include "dxsccctr.h"   /* NTC standard compiler definitions */
     2   beizhang MID("@(#)MID: UXDMAIGX.C 3.6-0 07/04/16");            /* module identification code */
     2   beizhang #include "uxdlibgx.cin"
     2   beizhang #include "stdio.h"
     2   beizhang #include "string.h"
     2   beizhang #include "stdarg.h"
     2   beizhang /*
     7   beizhang  * UX REGISTERS
     2   beizhang  */
     7   beizhang #define UX_CHIP_ID_REG                 0x00
    35   beizhang #define UX_FPGA_ID_REG                0xe8
     7   beizhang #define UX_CHIP_VERSION_REG            0x02
     7   beizhang #define UX_BUFF_CONFIG_REG             0x04
     7   beizhang #define UX_UTOPIA_CONFIG_REG           0x42
     7   beizhang #define UX_L1_BP_REG                   0x44
     7   beizhang #define UX_PORT_ENABLE_REG             0x48
     7   beizhang #define UX_PORT_POWER_REG              0x4A
     7   beizhang #define UX_DIAG_REG                    0x4C
     7   beizhang #define UX_SOFT_RESET_REG              0x4D
     7   beizhang #define UX_PLL_BW_REG                  0x4E
     7   beizhang #define UX_INTERRUPT_REG               0x64
     7   beizhang #define UX_INT_MASK_REG                0x66
     7   beizhang #define UX_STATUS_REG                  0x68
    27   beizhang #define UX_SCRAM_REG                    0xE6
    35   beizhang #define UX_REG_OFS_MAX                 0xFF  /* Max internal register index*/
    35   beizhang 
    35   beizhang /*DMX FPGA registers*/
    25   beizhang #define UX_FPGA_RESET_REG               0x100
     7   beizhang #define UX_FPGA_LOAD_REG               0x110
     7   beizhang #define UX_FPGA_DATA_MIN_REG               0x114
     7   beizhang #define UX_FPGA_DATA_MAX_REG               0x117
     7   beizhang /*extended registers*/
     7   beizhang #define UX_FPGA_CODE_DATA_REG_NUM    0x4
    35   beizhang #define FPGA_CONF_SIG_BIT__C                 0x2
    35   beizhang #define FPGA_CONF_STA_BIT__C                 0x3
    35   beizhang #define FPGA_CONF_DONE_SIG_BIT__C       0x4
     7   beizhang #define FPGA_CONF_ENABLE_SIG_BIT__C    0x6
     7   beizhang 
    35   beizhang #define RETRY_TIME_AREG__C				    50/*Retry time to access register*/
     2   beizhang /*
     2   beizhang  * bit defintions
     2   beizhang  */
     2   beizhang #define UX_BUFF_ENABLE          0x0001	/* to enable primary (lvl2) port   */
     2   beizhang #define UX_BUFF_DISABLE         0x0000	/* to enable secondary (lvl1) port */
     2   beizhang 
     2   beizhang #define UX_UTOPIA_CONF_UX1      0x0016  /* 8-bit, master, Utopia Lvl1      */
    29   beizhang #define UX_UTOPIA_CONF_UX21      0x0008  /* 16-bit, slave mode utopia LV2     */
     2   beizhang 
     2   beizhang #define UX_PORT_ENABLE_ALL      0x1F1F  /* all serial ports                */
     2   beizhang #define UX_PORT_ENABLE_NONE     0x0000  /* none of the serial ports        */
     2   beizhang 
     2   beizhang #define UX_PORT_POWER_ALL       0x1F1F  /* all serial ports                */
     2   beizhang #define UX_PORT_POWER_NONE      0x0000  /* none of the serial ports        */
     2   beizhang 
     7   beizhang #define UX_SR                   0x01	/* soft reset                      */
     2   beizhang /*test version by PVi 2.10.2002 -- pll_bw_init value changed from 0x400 to 0x20 */
     7   beizhang #define UX_PLL_BW_INIT          0x20  /* PLL and Phase Aligner Bandwidth */
     2   beizhang 
     2   beizhang #define UX_INT_MASK_ALL         0x7FE0	/* all interrupts enabled except for cell discard */
     2   beizhang #define UX_INT_MASK_NONE        0x0000	/* no interrupts                   */
     2   beizhang 
     7   beizhang /*Power Up Defaults (CHIP_VERSION & PLL_BW have undefined contents)*/
     2   beizhang #define UX_CHIP_ID              0xC200
    35   beizhang #define UX_FPGA_ID              0x2004
     2   beizhang #define UX_INIT_BUFF_CONFIG     0xE0F8	/* disabled                        */
     7   beizhang #define UX_INIT_UTOPIA_CONFIG   0
     7   beizhang #define UX_INIT_L1_BP		        0x1F00	/* disabled                        */
     7   beizhang #define UX_INIT_PORT_ENABLE     0
     7   beizhang #define UX_INIT_PORT_POWER      0
     7   beizhang #define UX_INIT_DIAG            0
     7   beizhang #define UX_INIT_INT_MASK        0
     2   beizhang 
     7   beizhang /* Masks to retrieve register contents*/
     2   beizhang #define UX_MASK_BUFF_CONFIG     0xE0F9
     2   beizhang #define UX_MASK_BUFF_PORT       0xE000
     2   beizhang #define UX_MASK_BUFF_UTOPIA     0x00F8
     2   beizhang #define UX_MASK_BUFF_ENABLE     0x0001
     2   beizhang #define UX_MASK_UTOPIA_CONFIG   0x001E
     2   beizhang #define UX_MASK_L1_BP           0x1F00
     7   beizhang #define UX_MASK_DIAG            0x3F
     2   beizhang #define UX_MASK_PORT_ENABLE     0x1F1F
     2   beizhang #define UX_MASK_PORT_POWER      0x1F1F
     2   beizhang #define UX_MASK_INT_MASK        0x7FFF
     2   beizhang 
     7   beizhang /*error codes*/
     7   beizhang #define UX_POWER_UP_OK          (-1)	/* positive number indicates error */
     2   beizhang 
     7   beizhang /* UX ASIC HW reset*/
     2   beizhang #define UX_HW_RESET_REG         0x100   /* Offset for UX ASIC HW reset pin */
     2   beizhang #define UX_HW_RESET_ON              0   /* Reset pin is active low         */
     2   beizhang #define UX_HW_RESET_OFF             1
     2   beizhang 
    37   beizhang #define UX_HW_LOOPBACK_REG      0x4c
     2   beizhang /*
     2   beizhang  * UX ASIC's base address location on PCI BUS (CCPC2, CCP10)
     2   beizhang  */
     2   beizhang #define PCI_VEND_ID__C          PCI_VENDOR_ID_T_RADISYS_C
     2   beizhang #define PCI_DEV_ID__C           0x0001
     7   beizhang #define PCI_DEV_INDEX__C        0
     7   beizhang #define PCI_BAR_ID__C           0x1C
     9   beizhang #define PCI_BAR_ID_CCP1D_C  0x14
     2   beizhang 
     7   beizhang /*Other constants*/
     7   beizhang #define UX_SERIAL_PORT_CNT__C   5	/* 5 serial ports per UX           */
     2   beizhang 
     7   beizhang #define UX_BUFFER_MAX__C        0x1F  /* number of buffers in UX ASIC    */
     7   beizhang #define UX_PORT_DISABLED__C     0xFF  /* denotes an unused UX port       */
     7   beizhang #define HW_RESET_REG_IND        0xFF  /* register index to cause HW reset*/
     2   beizhang 
     7   beizhang #define UC_INT_LVL_UX1          0x34
     2   beizhang #define CCPC2_INT_ID_UX1        INT_SIGNAL_ID_T_PCI_INT26_C
     2   beizhang #define CCP18_INT_ID_UX1        INT_SIGNAL_ID_T_PCI_INT0_C
    14   beizhang #define CCP1D_INT_ID_UX1        INT_SIGNAL_ID_T_PCI_INT19_C
     2   beizhang /* not used since catching UX1 interrupt is sufficient on NI4S1_A */
     7   beizhang #define UC_INT_LVL_UX1_A        0x37
     2   beizhang 
     7   beizhang #define SEM_RETRIES__C          3  /* How many times should we try to obtain the semaphore. */
     7   beizhang #define SEM_TIME_LIMIT__C       300  /* Waiting time for semaphore,x 1/100 s = 3 s */
     2   beizhang 
     7   beizhang #ifndef PIU_TYPE_T_CCPC2_A_C 
     7   beizhang #define PIU_TYPE_T_CCP18_A_C      0x18F
     7   beizhang #define PIU_TYPE_T_CCP18_B_C      0x190
     7   beizhang #define PIU_TYPE_T_CCP18_C_C      0x1B7
     2   beizhang #define PIU_TYPE_T_CCPC2_A_C      0x16E
     2   beizhang #endif
     7   beizhang #ifndef PIU_TYPE_T_CCP1D_A_C
     2   beizhang #define PIU_TYPE_T_CCP10_C        0x179
     7   beizhang #define PIU_TYPE_T_CCP1D_A_C      426 
     7   beizhang #define PIU_TYPE_T_CCP1D_B_C      427
     2   beizhang #endif
     2   beizhang 
     7   beizhang /* This constant has been removed from A8 sack so it is defined here as zero if it is not found from the sack: */
     2   beizhang #ifndef HW_INT_TYPE_T_NO_PRIOR_C
     2   beizhang #define HW_INT_TYPE_T_NO_PRIOR_C 0
     2   beizhang #endif
     2   beizhang 
     2   beizhang #ifndef NULL
     2   beizhang #define NULL 0
     2   beizhang #endif
     2   beizhang 
     7   beizhang 
     7   beizhang /*PCI related  (from pcireg.h)*/
     7   beizhang /* base classes */
     7   beizhang #define	PCI_CLASS_PREHISTORIC__C			      0x00
     7   beizhang #define	PCI_CLASS_MASS_STORAGE__C			0x01
     7   beizhang #define	PCI_CLASS_NETWORK__C				       0x02
     7   beizhang #define	PCI_CLASS_DISPLAY__C				       0x03
     7   beizhang #define	PCI_CLASS_MULTIMEDIA__C				0x04
     7   beizhang #define	PCI_CLASS_MEMORY__C				       0x05
     7   beizhang #define	PCI_CLASS_BRIDGE__C				       0x06
     7   beizhang #define	PCI_CLASS_COMMUNICATIONS__C			0x07
     7   beizhang #define	PCI_CLASS_SYSTEM__C				       0x08
     7   beizhang #define	PCI_CLASS_INPUT__C					0x09
     7   beizhang #define	PCI_CLASS_DOCK__C					       0x0a
     7   beizhang #define	PCI_CLASS_PROCESSOR__C				0x0b
     7   beizhang #define	PCI_CLASS_SERIALBUS__C				0x0c
     7   beizhang #define	PCI_CLASS_UNDEFINED__C				0xff
     7   beizhang 
     7   beizhang /*Subclass of BRIDGE*/
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_HOST__C	              0x00
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_ISA__C			0x01
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_EISA__C		       0x02
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_MC__C			0x03
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_PCI__C			0x04
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_PCMCIA__C		0x05
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_NUBUS__C		0x06
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_CARDBUS__C		0x07
     7   beizhang #define	PCI_SUBCLASS_BRIDGE_MISC__C		       0x80
     7   beizhang 
     7   beizhang 
     2   beizhang /* MACROS *******************************************************************/
     2   beizhang /*
     2   beizhang  * this should be used when writing to the buffer config register
     2   beizhang  * it helps make the code more readable
     2   beizhang  */
     2   beizhang #define BUFF_CONFIG_SETUP(port, add, be) (((port) << 13) | ((add) << 3) | (be))
     2   beizhang 
     2   beizhang /*
     7   beizhang  * this should be used to get an offset to which buffer configuration register  to write to
     2   beizhang  */
     2   beizhang #define BUFF_CONFIG_OFFSET(buf_num) (UX_BUFF_CONFIG_REG + ((buf_num) << 1))
    10   beizhang /*
     2   beizhang #define LOG_WRITE__R(info_ptr, log_data)\
     2   beizhang   write_to_log (LOG_TYPE_T_DWORD_T_C,\
     2   beizhang   (log_write_item_t) &log_data, 1,(log_text_info_t)info_ptr)
    10   beizhang */
    10   beizhang #define LOG_WRITE__R(info_ptr, log_data) printc(info_ptr,log_data)
     2   beizhang 
     7   beizhang #define CHECK_UXLIB_ENTRY__R(lib_initialized) {\
     7   beizhang  if ( !do_enter__r() ) {\
     7   beizhang     return TIMEOUT_ERROR_EC;\
     7   beizhang   }\
     7   beizhang   if ( !lib_initialized ) {\
     7   beizhang     do_exit__r();\
     7   beizhang     TEST_WRITE__R("UXDLIB: not initialized", lib_initialized);\
     7   beizhang     return UX_LIB_NOT_INITIALIZED_EC;\
     7   beizhang   }}
     7   beizhang 
     7   beizhang #define ASSSERT_STATUS__R(status) {if(status!=SUCCESS_EC) return status;}
     7   beizhang 
     2   beizhang /* Debug log writings
     2   beizhang  */
     2   beizhang #ifdef UXD_DEBUG
     2   beizhang   #define TEST_WRITE__R(info_ptr, log_data)\
     2   beizhang     write_to_log (LOG_TYPE_T_DWORD_T_C,\
     2   beizhang       (log_write_item_t) &log_data, 1,(log_text_info_t)info_ptr)
     2   beizhang #else
     2   beizhang   #define TEST_WRITE__R(info_ptr, log_data)
     2   beizhang #endif
     2   beizhang 
     2   beizhang /* UXDLIB INTERNAL DATA STRUCTURES *******************************************/
     2   beizhang 
     7   beizhang mphy_port_number_t     g_ux1_addr;
    35   beizhang byte                              g_ux1_port;
    35   beizhang bool                              g_lib_initialized = 0;
    35   beizhang bool                              g_hw_initialized = 0;
    35   beizhang piu_type_t                     g_my_piu_type;
    35   beizhang ux_hw_block_type_t       g_ux_block_type;
    35   beizhang dword                            g_ux1_base_addr;
    35   beizhang 
    35   beizhang bool                              g_fpga_loaded = F;
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: log_printf
     2   beizhang  *  Writes a test entry to the computer log with a call to write_to_log.
     2   beizhang  *  example:
     2   beizhang  * log_printf( "UXDLIB: dump_list: begin", "init = %x free = %x data = %p",
     2   beizhang  *              header->init, header->free, header->data );
     2   beizhang  *****************************************************************************/
     2   beizhang PRIVATE void
     2   beizhang log_printf
     2   beizhang (
     2   beizhang  const char             *title, /* log text */
     2   beizhang  const char             *fmt,   /* user data */
     2   beizhang  ...
     2   beizhang )
     2   beizhang {
     2   beizhang     char buf[ 240 ];
     2   beizhang     va_list arg_ptr;
     2   beizhang     byte len;
     2   beizhang 
     2   beizhang     va_start( arg_ptr, fmt );
     2   beizhang     len = vsprintf( buf, fmt, arg_ptr );
     2   beizhang     va_end( arg_ptr );
     2   beizhang 
     2   beizhang     write_to_log( LOG_TYPE_T_TEXT_T_C, (log_write_item_t) buf,
     2   beizhang       (log_info_item_count_t) len, (log_text_info_t) title );
     2   beizhang }
    10   beizhang 
    10   beizhang PRIVATE void printc
    10   beizhang (
    10   beizhang  const char *format,
    10   beizhang  ...
    10   beizhang  )
    10   beizhang {
    10   beizhang      char  buf[500]; /* for printing purposes       */
    10   beizhang 
    10   beizhang      va_list     args;
    10   beizhang 
    10   beizhang      va_start( args, format );
    10   beizhang      vsprintf( buf, format, args );
    10   beizhang      text_out( (clu_disp_text_t)buf );
    10   beizhang      va_end( args );
    10   beizhang }
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: do_enter__r
     2   beizhang  *  Makes a semaphore operation enter_region() and checks status.
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    T                         - ok
     2   beizhang  *    F                         - error during semaphore operation
     2   beizhang  *****************************************************************************/
     2   beizhang PRIVATE bool
     7   beizhang do_enter__r()
     2   beizhang {
     2   beizhang   byte                i;
     2   beizhang   error_t             ec;
     2   beizhang   for (i = 0; i < SEM_RETRIES__C; i++) {
     2   beizhang     enter_region( UXDLIB_SEM, SEM_TIME_LIMIT__C );
     2   beizhang     if ( time_out() ) {
     2   beizhang       TEST_WRITE__R("UXDLIB: enter_region() timed out", i);
     7   beizhang     }else if ( SUCCESS_EC != (ec = osc_status()) ) {
     2   beizhang       TEST_WRITE__R("UXDLIB: enter_region() failed", ec);
     7   beizhang     }else {
     2   beizhang       return T;
     2   beizhang     }
     2   beizhang   }
     2   beizhang   TEST_WRITE__R("UXDLIB: didn't get semaphore!", i);
     2   beizhang   return F;
     2   beizhang }
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: do_exit__r
     2   beizhang  *  Makes a semaphore operation exit_region() and checks status.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    -
     2   beizhang  *****************************************************************************/
     7   beizhang PRIVATE void do_exit__r()
     2   beizhang {
     2   beizhang   error_t             ec;
     2   beizhang   exit_region();
     2   beizhang   if ( SUCCESS_EC != (ec = osc_status()) ) {
     7   beizhang     TEST_WRITE__R("UXDLIB: exit_region() failed", ec);}
     2   beizhang }
     2   beizhang 
     2   beizhang 
     2   beizhang /****************************************************************************
     7   beizhang  *  FUNCTION: ux_read_reg_byte__r
     2   beizhang  ****************************************************************************
     2   beizhang  *
     7   beizhang  *  Reads an 8-bit register on UX ASIC.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     7   beizhang  *    Contents of register
     2   beizhang  *
     2   beizhang  ***************************************************************************/
     7   beizhang PRIVATE byte ux_read_reg_byte__r
     2   beizhang (
     7   beizhang   dword base_addr,
     7   beizhang   dword offset
     2   beizhang )
     2   beizhang {
     7   beizhang   return input_byte_r((io_address_t)base_addr+offset);
     7   beizhang } /* end ux_read_reg_byte__r */
     2   beizhang 
     7   beizhang /****************************************************************************
     7   beizhang  *  FUNCTION: ux_write_reg_byte__r
     7   beizhang  ****************************************************************************
     7   beizhang  *
     7   beizhang  *  Writes an 8-bit register on UX ASIC.
     7   beizhang  *
     7   beizhang  *  RETURN VALUE:
     7   beizhang  *    -
     7   beizhang  *
     7   beizhang  ***************************************************************************/
     7   beizhang PRIVATE void ux_write_reg_byte__r
     7   beizhang (
     7   beizhang   dword base_addr,
     7   beizhang   dword offset,
     7   beizhang   byte value
     7   beizhang )
     7   beizhang {
     7   beizhang   #ifdef UXD_DEBUG
     7   beizhang   log_printf( "UXDLIB: write_reg: ", "index = %x value = %x",
     7   beizhang     offset, value);
     7   beizhang   #endif
     7   beizhang   output_byte_r((io_address_t)base_addr+offset, value);
     7   beizhang }
     2   beizhang 
     7   beizhang /****************************************************************************
     7   beizhang  *  FUNCTION: ux_write_reg_word__r
     7   beizhang  ****************************************************************************
     7   beizhang  *
     7   beizhang  *  Writes a 16-bit register on UX ASIC as two 8-bit operations.
     7   beizhang  *  Assume little endian byte order.
     7   beizhang  *
     7   beizhang  *  RETURN VALUE:
     7   beizhang  *    -
     7   beizhang  ***************************************************************************/
     7   beizhang PRIVATE void ux_write_reg_word__r
     7   beizhang (
     7   beizhang   dword base_addr,
     7   beizhang   dword offset,
     7   beizhang   word value
     7   beizhang )
     7   beizhang {
     7   beizhang   /* UX ASIC is in little endian mode -> swap byte order */
     7   beizhang   #ifdef UXD_DEBUG
     7   beizhang   log_printf( "UXDLIB: write_word: ", "index = %x value = %x",
     7   beizhang     offset, value);
     7   beizhang   #endif
     7   beizhang   ux_write_reg_byte__r(base_addr, offset, value & 0xFF);
     7   beizhang   ux_write_reg_byte__r(base_addr, offset+1, (value >> 8) & 0xFF);
     2   beizhang }
     2   beizhang 
     7   beizhang /****************************************************************************
     7   beizhang  *  FUNCTION: ux_read_reg_word__r
     7   beizhang  ****************************************************************************
     7   beizhang  *
     7   beizhang  *  Reads a 16-bit register on UX ASIC as two 8-bit operations.
     7   beizhang  *  Assume little endian byte order.
     7   beizhang  *
     7   beizhang  *  RETURN VALUE:
     7   beizhang  *    Contents of register
     7   beizhang  *
     7   beizhang  ****************************************************************************/
     7   beizhang PRIVATE word ux_read_reg_word__r
     7   beizhang (
     7   beizhang   dword base_addr,
     7   beizhang   dword offset
     7   beizhang )
     7   beizhang {
     7   beizhang   word				  value;
     2   beizhang 
     7   beizhang   /* UX ASIC is in little endian mode -> swap byte order */
     7   beizhang   value = ux_read_reg_byte__r(base_addr, offset);
     7   beizhang   value = value | (ux_read_reg_byte__r(base_addr, offset+1) << 8);
     7   beizhang   #ifdef UXD_DEBUG
     7   beizhang   log_printf( "UXDLIB: read_reg: ", "index = %x value = %x",
     7   beizhang     offset, value);
     7   beizhang   #endif
     7   beizhang   return value;
     7   beizhang }
    35   beizhang PRIVATE bool is_fpga_loaded__r(dword  p_base_addr)
    35   beizhang {
    35   beizhang     if ( (ux_read_reg_word__r(p_base_addr, UX_CHIP_ID_REG) & 0xFFFF)!= UX_CHIP_ID ) 
    35   beizhang         return F;
    35   beizhang     else
    35   beizhang 	 return T;
    35   beizhang }
    35   beizhang 
    35   beizhang PRIVATE bool is_asic__r(dword  p_base_addr)
    35   beizhang {
    35   beizhang      if ( (ux_read_reg_word__r(p_base_addr, UX_FPGA_ID_REG) & 0xFFFF)!= UX_FPGA_ID ) 
    35   beizhang         return T;
    35   beizhang     else
    35   beizhang 	 return F;
    35   beizhang }
    35   beizhang 
    35   beizhang PRIVATE bool is_master_l1__r(dword  p_base_addr)
    35   beizhang {
    35   beizhang     if ( (ux_read_reg_word__r(p_base_addr, UX_UTOPIA_CONFIG_REG) & 0xFFFF)!= UX_UTOPIA_CONF_UX21 ) 
    35   beizhang         return T;
    35   beizhang     else
    35   beizhang 	 return F;
    35   beizhang }
     9   beizhang PRIVATE error_t ux_get_mem_base__r(
     9   beizhang      piu_type_t            piu_type,
     9   beizhang      byte                     pci_bus,
     9   beizhang      byte                     pci_dev_fun_id,
     9   beizhang      pci_mem_type_t   *pci_mem_type_p,
     9   beizhang      dword                  *pci_base_p,
     9   beizhang      dword                  *pci_mem_size_p
     9   beizhang )
     9   beizhang {
     9   beizhang     error_t             err_status;
     9   beizhang     if(piu_type == PIU_TYPE_T_CCP1D_A_C || piu_type == PIU_TYPE_T_CCP1D_B_C)
     9   beizhang         err_status = pci_get_mem_base_r(pci_bus, pci_dev_fun_id, PCI_BAR_ID_CCP1D_C,
     9   beizhang                      pci_mem_type_p, pci_base_p, pci_mem_size_p);
     9   beizhang     else
     9   beizhang         err_status = pci_get_mem_base_r(pci_bus, pci_dev_fun_id, PCI_BAR_ID__C,
     9   beizhang                      pci_mem_type_p, pci_base_p, pci_mem_size_p);
     9   beizhang     if( err_status != SUCCESS_EC ) {
     9   beizhang     LOG_WRITE__R("UXDLIB: Can't read PCI base address", err_status);
     9   beizhang     }
     9   beizhang     return err_status;
     9   beizhang }
     7   beizhang PRIVATE error_t ux_get_pci_bus__r
     7   beizhang (
     7   beizhang   piu_type_t    piu_type,
     7   beizhang   byte          *pci_bus_ptr,
     7   beizhang   byte          *pci_dev_fun_id_ptr,
     7   beizhang   pci_device_status_t  *pci_dev_stat_ptr
     7   beizhang )
     7   beizhang {
     7   beizhang   error_t err_status;
     7   beizhang   switch(piu_type)
     7   beizhang   {
     7   beizhang     case PIU_TYPE_T_CCPC2_C:
     7   beizhang     case PIU_TYPE_T_CCPC2_A_C:
     7   beizhang     case PIU_TYPE_T_CCP10_C:
     7   beizhang        err_status = pci_find_map_device_r(COMPUTER_T_REL_OWN_UNIT_C, PCI_VEND_ID__C,
     7   beizhang                    PCI_DEV_ID__C, PCI_DEV_INDEX__C, pci_bus_ptr, pci_dev_fun_id_ptr,
     7   beizhang                    pci_dev_stat_ptr);
     9   beizhang        break;
     7   beizhang     case PIU_TYPE_T_CCP18_A_C:
     7   beizhang     case PIU_TYPE_T_CCP18_B_C:
     7   beizhang     case PIU_TYPE_T_CCP18_C_C:
     9   beizhang       err_status =  pci_find_map_class_code_r(COMPUTER_T_REL_OWN_UNIT_C, PCI_CLASS_BRIDGE__C, PCI_SUBCLASS_BRIDGE_MISC__C, 0, 0,
     9   beizhang                                            pci_bus_ptr, pci_dev_fun_id_ptr, pci_dev_stat_ptr);
     9   beizhang       break;
     7   beizhang     case PIU_TYPE_T_CCP1D_A_C:
     7   beizhang     case PIU_TYPE_T_CCP1D_B_C:
    10   beizhang       err_status =  pci_find_map_class_code_r(COMPUTER_T_REL_OWN_UNIT_C, PCI_CLASS_BRIDGE__C, PCI_SUBCLASS_BRIDGE_MISC__C, 0, 0,
     7   beizhang                                            pci_bus_ptr, pci_dev_fun_id_ptr, pci_dev_stat_ptr);
     9   beizhang         break;
     7   beizhang     default:
    10   beizhang       LOG_WRITE__R("UXDLIB: PIU type not supported %x", piu_type);
    10   beizhang       printc("piu type %d\n",piu_type);
     7   beizhang       err_status =UX_INVALID_OPERATION_EC;
     9   beizhang       return err_status;
     7   beizhang  }
     9   beizhang   if ( err_status != SUCCESS_EC ){
     9   beizhang         LOG_WRITE__R("UXDLIB: Radisys PCI I/O bridge not found", err_status);
     9   beizhang         LOG_WRITE__R("PIU is", piu_type);}
     7   beizhang  return err_status;
     7   beizhang }
     2   beizhang /****************************************************************************
     7   beizhang  *  FUNCTION: ux_get_pci_base_addr__r
     2   beizhang  ****************************************************************************
     2   beizhang  *
     2   beizhang  *  Retrieves the I/O base address for UX ASIC, where
     2   beizhang  *  the chip connects to PCI bus through an I/O bridge. Thus its
     2   beizhang  *  base address needs to be read from bridge's PCI bus configuration
     2   beizhang  *  registers.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC after successful configuration, PBMLIB related error code
     2   beizhang  *    otherwise.
     2   beizhang  *
     2   beizhang  ***************************************************************************/
     7   beizhang PRIVATE error_t ux_get_pci_base_addr__r
     2   beizhang (
     7   beizhang   dword * far   ux_base,
     7   beizhang   piu_type_t    piu_type
     2   beizhang )
     2   beizhang {
     2   beizhang   error_t             err_status;
     2   beizhang   byte                pci_dev_fun_id;
     2   beizhang   byte                pci_bus;
     2   beizhang   pci_device_status_t pci_dev_stat;
     2   beizhang   pci_mem_type_t      pci_mem_type;
     2   beizhang   dword               pci_base;
     2   beizhang   dword               pci_mem_size;
     2   beizhang 
     2   beizhang   if ( ux_base == NULL ) {
     2   beizhang     TEST_WRITE__R("UXDLIB: null pointer passed as ux_base", ux_base);
     2   beizhang     return UNSUCCESSFUL_EC;
     2   beizhang   }
    10   beizhang 
    10   beizhang #ifndef VEN_ADLINK
     2   beizhang   err_status = pci_get_services_present_stat_r(COMPUTER_T_REL_OWN_UNIT_C,
     2   beizhang                  &pci_bus);
     7   beizhang   if(err_status != SUCCESS_EC){
     7   beizhang     LOG_WRITE__R("UXDLIB: PCI bus services not present", err_status);
     7   beizhang     return err_status;
     7   beizhang   }
     7   beizhang   err_status = ux_get_pci_bus__r(piu_type,&pci_bus,&pci_dev_fun_id,&pci_dev_stat);
     7   beizhang   if ( err_status != SUCCESS_EC ) {
     7   beizhang     return err_status;
     7   beizhang   }
    10   beizhang   printc("pci_bus %x, pci_fun_id %x, pci_stat %x\n", pci_bus,pci_dev_fun_id, pci_dev_stat);
     9   beizhang   err_status = ux_get_mem_base__r(piu_type,pci_bus, pci_dev_fun_id,
     2   beizhang                      &pci_mem_type, &pci_base, &pci_mem_size);
     7   beizhang   if( err_status != SUCCESS_EC ) {
     7   beizhang     return err_status;
     7   beizhang   }
    10   beizhang   printc("type %x mem base %x size %x\n",pci_mem_type,pci_base,pci_mem_size);
     7   beizhang   TEST_WRITE__R("UXMANA_TEST: PCI base addr ok", pci_base);
     7   beizhang   if ( pci_mem_type == PCI_MEM_TYPE_T_IO_BASE_C ) {
     2   beizhang           *ux_base = pci_base;
     7   beizhang   }else {
     7   beizhang     err_status = UNSUCCESSFUL_EC;
     7   beizhang     LOG_WRITE__R("UXDLIB: Invalid PCI memory type", pci_mem_type);
     2   beizhang   }
    10   beizhang #else
    10   beizhang   *ux_base=0x2000;
    10   beizhang   err_status = SUCCESS_EC;
    10   beizhang   
    10   beizhang   printc(" Vendor is ADLINK BASE addr is %x\n",*ux_base);
    10   beizhang #endif
    10   beizhang  
     2   beizhang   return err_status;
     2   beizhang }
    20   beizhang /*****************************************************************************
    20   beizhang  *  FUNCTION: update_conf_variables__r
    20   beizhang  *****************************************************************************
    20   beizhang  *
    20   beizhang  *  Releases UX ASICs from reset and checks whether they've been
    20   beizhang  *  configured already. If so, update library configuration variables.
    20   beizhang  *
    20   beizhang  *  RETURN VALUE:
    20   beizhang  *    SUCCESS_EC                - conf variables updated ok
    20   beizhang  *    UX_INVALID_OPERATION_EC   - UX1 hardware block is not present
    20   beizhang  *
    20   beizhang  *****************************************************************************/
    20   beizhang PRIVATE error_t update_conf_variables__r
    20   beizhang (
    20   beizhang )
    20   beizhang {
    20   beizhang   byte                ind, chip_ind, port;
    20   beizhang   word                reg_value;
    35   beizhang   
    20   beizhang   /* On CCPC2 the UX ASIC is in HW reset state after board powerup and needs to
    20   beizhang    * be released by software. On 486 based units the reset is always
    20   beizhang    * released automatically by the board hardware (J. Seppanen, May 2k)
    35   beizhang    * Should reset here during startup . For CCP1D_A, this is done during fpga loading
    20   beizhang    */
    35   beizhang 
    20   beizhang   if ( (g_my_piu_type == PIU_TYPE_T_CCPC2_C)   ||
    20   beizhang        (g_my_piu_type == PIU_TYPE_T_CCPC2_A_C) ||
    20   beizhang        (g_my_piu_type == PIU_TYPE_T_CCP10_C)   ||
    20   beizhang        (g_my_piu_type == PIU_TYPE_T_CCP18_A_C) ||
    20   beizhang        (g_my_piu_type == PIU_TYPE_T_CCP18_B_C) ||
    20   beizhang        (g_my_piu_type == PIU_TYPE_T_CCP18_C_C))
    20   beizhang   {
    20   beizhang     ux_write_reg_byte__r(g_ux1_base_addr, UX_HW_RESET_REG, UX_HW_RESET_OFF);
    20   beizhang     delay(1);
    20   beizhang   }
    20   beizhang 
    20   beizhang   /* check whether UX1 block is present */
    20   beizhang   if ( (ux_read_reg_word__r(g_ux1_base_addr, UX_CHIP_ID_REG) & 0xFFFF)
    20   beizhang        != UX_CHIP_ID ) {
    21   beizhang     LOG_WRITE__R("UXDLIB: Invalid register value after reset %x", g_ux1_base_addr);
    20   beizhang     return UX_INVALID_OPERATION_EC;
    20   beizhang   }
    20   beizhang 
    20   beizhang   /* clear configuration variables */
    20   beizhang   g_ux1_addr = MPHY_PORT_NUMBER_T_UNSPEC_C;
    20   beizhang   g_ux1_port = UX_PORT_DISABLED__C;
    20   beizhang 
    20   beizhang   /* Update configuration variables if UX1 was already configured.
    20   beizhang      No checks for illegal configurations */
    20   beizhang   if ( (ux_read_reg_word__r(g_ux1_base_addr, UX_UTOPIA_CONFIG_REG) &
    20   beizhang        UX_MASK_UTOPIA_CONFIG) != UX_INIT_UTOPIA_CONFIG ) {
    20   beizhang 
    20   beizhang     TEST_WRITE__R("UXDLIB: UX ASIC already initialized; updating state", g_ux1_base_addr);
    20   beizhang     g_hw_initialized = T;
    20   beizhang     /* UX1 */
    20   beizhang     reg_value = ux_read_reg_word__r(g_ux1_base_addr, UX_L1_BP_REG);
    20   beizhang     if ( (reg_value &= UX_MASK_L1_BP) != UX_INIT_L1_BP ) {
    20   beizhang       ind = reg_value >> 8; /* buffer index */
    20   beizhang       reg_value = ux_read_reg_word__r(g_ux1_base_addr,
    20   beizhang                     BUFF_CONFIG_OFFSET(ind)) & UX_MASK_BUFF_CONFIG;
    20   beizhang       if ( reg_value != UX_INIT_BUFF_CONFIG ) {
    20   beizhang         g_ux1_port = (reg_value & UX_MASK_BUFF_PORT) >> 13;
    20   beizhang         g_ux1_addr = ind;
    20   beizhang       }
    20   beizhang     }
    20   beizhang 
    20   beizhang   }
    20   beizhang 
    20   beizhang   return SUCCESS_EC;
    20   beizhang } /* end update_conf_variables__r */
    35   beizhang PRIVATE error_t ux_conf_ux1_port__r
    35   beizhang (
    35   beizhang      byte                   port_index,
    35   beizhang      mphy_port_number_t     utopia_address
    35   beizhang )
    35   beizhang {
    35   beizhang     if ( g_ux1_addr != MPHY_PORT_NUMBER_T_UNSPEC_C ) {
    35   beizhang         TEST_WRITE__R("UXDLIB: disabling current configuration", port_index);
    35   beizhang         if(is_master_l1__r(g_ux1_base_addr)){
    35   beizhang            ux_write_reg_word__r(g_ux1_base_addr, UX_L1_BP_REG, UX_INIT_L1_BP);        
    35   beizhang         }
    35   beizhang         ux_write_reg_word__r(g_ux1_base_addr, BUFF_CONFIG_OFFSET(g_ux1_addr),UX_INIT_BUFF_CONFIG);
    35   beizhang    }
    35   beizhang   
    35   beizhang    if (is_master_l1__r(g_ux1_base_addr)) 
    35   beizhang    {
    35   beizhang        ux_write_reg_word__r(g_ux1_base_addr, BUFF_CONFIG_OFFSET(utopia_address),BUFF_CONFIG_SETUP(port_index, utopia_address, UX_BUFF_DISABLE));
    35   beizhang 	ux_write_reg_word__r(g_ux1_base_addr, UX_L1_BP_REG, utopia_address << 8);
    35   beizhang    }
    35   beizhang    else{
    35   beizhang    	ux_write_reg_word__r(g_ux1_base_addr, BUFF_CONFIG_OFFSET(utopia_address),BUFF_CONFIG_SETUP(port_index, utopia_address, UX_BUFF_ENABLE));
    35   beizhang    }
    35   beizhang   
    35   beizhang   g_ux1_addr = utopia_address;
    35   beizhang   g_ux1_port = port_index;
    20   beizhang 
    35   beizhang   return SUCCESS_EC;
    35   beizhang 
    35   beizhang }
    35   beizhang 
    18   beizhang PRIVATE error_t ux_load_n_bytes__r(
     7   beizhang     file_handle_t p_file_handle,
     7   beizhang     offset           p_offset, 
    20   beizhang     dword*         p_read_count_ptr,
    20   beizhang     dword            p_base_addr,
    20   beizhang     dword            p_number)
     7   beizhang {
     7   beizhang     error_t     status;
    21   beizhang     /*byte        value;*/
    21   beizhang     dword       value;
    20   beizhang     int         i;
    20   beizhang     byte        buffer[UX_FPGA_CODE_DATA_REG_NUM];
     7   beizhang     
    20   beizhang     if (p_number > UX_FPGA_CODE_DATA_REG_NUM) {
    20   beizhang 	 printc("number of bytes is wrong. number is %x\n", p_number);
    20   beizhang         return UNSUCCESSFUL_EC;
    20   beizhang     }
    20   beizhang 
    20   beizhang     memset(buffer, 0xFF, UX_FPGA_CODE_DATA_REG_NUM);
    21   beizhang 
     7   beizhang     status = file_read (p_read_count_ptr,
     7   beizhang                               p_file_handle,     
     7   beizhang                               p_offset,
     7   beizhang                               (long_pointer_t)buffer,
    20   beizhang                               p_number);
     7   beizhang     if(status!=SUCCESS_EC)
    20   beizhang     {
    20   beizhang         printc("file_read is wrong. status %x\n",status);
     7   beizhang         return status;
    20   beizhang     }
    20   beizhang   value = ((dword)buffer[0]) + 
    20   beizhang             ((dword)buffer[1] << 8) + 
    20   beizhang             ((dword)buffer[2] << 16) + 
    20   beizhang             ((dword)buffer[3] << 24);
    21   beizhang    output_dword_r((io_address_t)p_base_addr+UX_FPGA_DATA_MIN_REG, value);
    21   beizhang 	/*
    20   beizhang    for(i=UX_FPGA_CODE_DATA_REG_NUM-*p_read_count_ptr;i<UX_FPGA_CODE_DATA_REG_NUM;i++)
    21   beizhang         ux_write_reg_byte__r(p_base_addr, UX_FPGA_DATA_MAX_REG-i, buffer[UX_FPGA_CODE_DATA_REG_NUM-i-1]);*/
     7   beizhang     return status;
     7   beizhang }
     7   beizhang PRIVATE error_t ux_load_fpga__r( file_handle_t p_file_handle,bool p_forced)
     7   beizhang {
     7   beizhang     byte                    value =0;
    20   beizhang     dword                  base_addr, file_len,read_len, file_loc, read_count;
    20   beizhang     offset                   f_offset;
    20   beizhang     int                        retry =0;
     7   beizhang     error_t                 status = SUCCESS_EC;
    20   beizhang     read_len = 0;
    20   beizhang     file_loc   = 0;
    20   beizhang     read_count = 0;
    21   beizhang 
     7   beizhang     status = ux_get_pci_base_addr__r(&base_addr,g_my_piu_type);
     7   beizhang     ASSSERT_STATUS__R(status);
     7   beizhang 
     7   beizhang     status = file_length(&file_len,p_file_handle);
     7   beizhang     ASSSERT_STATUS__R(status);
    21   beizhang     log_printf("","file len %x\n", file_len);	
    18   beizhang     f_offset = (offset)(0);
    20   beizhang 
    25   beizhang    /*Set 0x100 UX reset register */
    25   beizhang    ux_write_reg_byte__r(base_addr, UX_FPGA_RESET_REG,0x1);
    25   beizhang    delay(1);
    21   beizhang     /*Set 0x110 UX Loading control register of DMX FPGA.*/
    21   beizhang     /*Select the Passive Serial Mode:set D6 as 1*/		
    20   beizhang     ux_write_reg_byte__r(base_addr, UX_FPGA_LOAD_REG,0x40);
    21   beizhang     delay(2);
    20   beizhang     do{
    20   beizhang         value = ux_read_reg_byte__r(base_addr, UX_FPGA_LOAD_REG);
    20   beizhang 	 retry +=1;
    21   beizhang 	 delay(10);
    21   beizhang     }while(((value&0x5c) != 0x40) && (retry<50));
    21   beizhang     if((value&0x5c) != 0x40){
    21   beizhang         printc("can not set Passive mode and nConfig low,. value %x\n",value);
    21   beizhang 	 return 0xFFF5;
    21   beizhang     }
    21   beizhang     retry  = 0;
    21   beizhang     value = 0;
    21   beizhang     /*Select the Passive Serial Mode */
    21   beizhang     ux_write_reg_byte__r(base_addr, UX_FPGA_LOAD_REG,0x44);
    21   beizhang     delay(2);
    21   beizhang     do{
    21   beizhang         value = ux_read_reg_byte__r(base_addr, UX_FPGA_LOAD_REG);
    21   beizhang 	 retry +=1;
    21   beizhang 	 delay(10);
    35   beizhang     }while(((value&0x5c) != 0x4c) && (retry<RETRY_TIME_AREG__C));
    21   beizhang     if((value&0x5c) != 0x4c){
    21   beizhang         printc("can not set Passive mode and nConfig low while status&config high,. value %x\n",value);
    21   beizhang 	 return 0xFFF5;
    21   beizhang     }
    20   beizhang     /* printc("UX_FPGA_LOAD_REG %x\n", value);
    20   beizhang      if(value&(1<<FPGA_CONFIG_STA_BIT__C)) return 0xFFF5;*/
    20   beizhang 	
    21   beizhang     while (status==SUCCESS_EC)
     7   beizhang     {
    21   beizhang         
    20   beizhang         read_len = ((file_len-file_loc)>=UX_FPGA_CODE_DATA_REG_NUM)?UX_FPGA_CODE_DATA_REG_NUM:(file_len-file_loc);
    21   beizhang         if(read_len<=0)
    21   beizhang 	    break;
    21   beizhang 		
    21   beizhang         status = ux_load_n_bytes__r(p_file_handle,f_offset,&read_count,base_addr,read_len);
    21   beizhang 	 if(read_len != read_count)
    21   beizhang 	 	printc("read not expected %x:%x \n", read_len, read_count);
    21   beizhang 	 
    21   beizhang 	 value = ux_read_reg_byte__r(base_addr, UX_FPGA_LOAD_REG);
    21   beizhang 	 #ifndef VEN_Emerson
    20   beizhang         if(!(value&(1<<FPGA_CONF_STA_BIT__C))) 
    20   beizhang 	 {
    20   beizhang 	       printc("error happened after loadin %d bytes load_Reg:0x%x %x\n",read_len,value,file_loc);
    20   beizhang 	  	return 0xFFF5;
    20   beizhang 	 }
    20   beizhang 	 if(value&(1<<FPGA_CONF_DONE_SIG_BIT__C)) 
    20   beizhang 	 {
    21   beizhang 	       printc("write offset %x, file_len %x\n",f_offset, file_len);
    20   beizhang 	  	return SUCCESS_EC;
    20   beizhang 	 }
    21   beizhang 	 #endif
    21   beizhang 	/* if((value&0x5c)==0x5c)
    21   beizhang 	 {
    21   beizhang 	       printc("write offset %x, file_len %x\n",f_offset, file_len);
    21   beizhang 	  	return SUCCESS_EC;
    21   beizhang 	 }	*/
    21   beizhang          file_loc+=read_len;
    21   beizhang          f_offset =(offset)file_loc; 		 
     7   beizhang     }
    20   beizhang 
    21   beizhang     printc("load file len %x, loaded %x\n",file_len, file_loc-read_len);
    21   beizhang 	
    20   beizhang     if(status != SUCCESS_EC)
    20   beizhang         printc("read file failed %x status %x\n",f_offset,status);
    20   beizhang     
     7   beizhang     delay(1);/*hundredths of a second*/
    21   beizhang     retry = 0;
    21   beizhang     value =0;
    21   beizhang     do{
    21   beizhang          value = ux_read_reg_byte__r(base_addr, UX_FPGA_LOAD_REG);
    21   beizhang          retry +=1;
    21   beizhang 	  delay(10);
    35   beizhang     }while(retry<RETRY_TIME_AREG__C && (value&0x5c) != 0x5c);
     7   beizhang     /*check if DONE is high*/
    21   beizhang     if((status==SUCCESS_EC)&&(value&(1<<FPGA_CONF_DONE_SIG_BIT__C)))
    21   beizhang         printc("UXDLIB: load FPGA done %x\n", (value&0x5c));
     7   beizhang     else
    18   beizhang     {
    18   beizhang         printc("UXDLIB: load FPGA failed %x status %x\n", value,status);
    18   beizhang 	 status = UNSUCCESSFUL_EC;
    18   beizhang     }
     7   beizhang     return status;
     7   beizhang }
     2   beizhang /****************************************************************************
     2   beizhang  *  FUNCTION: ux_test_chip_hw__r
     2   beizhang  ****************************************************************************
     2   beizhang  *
     2   beizhang  *  Test the functioing of a single UX ASIC chip. The test must not disturb
     2   beizhang  *  chip's normal operation. Thus the test is totally based on reading chip's
     2   beizhang  *  identification register and verifying a write operation on the interrupt
     2   beizhang  *  mask register.
     2   beizhang  *
     2   beizhang  *  Another possibility to test the UX ASIC HW is reading the status register.
     2   beizhang  *  It tells whether there is a cable and another functional UX ASIC connected
     2   beizhang  *  to some serial port. The disabled serial ports should be masked away from
     2   beizhang  *  the status register.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC after successful test, UNSUCCESSFUL_EC otherwise
     2   beizhang  *
     2   beizhang  ***************************************************************************/
     2   beizhang PRIVATE error_t ux_test_chip_hw__r
     2   beizhang (
     2   beizhang   dword ux_base
     2   beizhang )
     2   beizhang {
     2   beizhang   error_t             err_status;
     2   beizhang 
     2   beizhang   err_status = SUCCESS_EC;
     2   beizhang 
     2   beizhang   if ( ux_read_reg_word__r(ux_base, UX_CHIP_ID_REG) != UX_CHIP_ID ) {
     2   beizhang     TEST_WRITE__R("UXDLIB: chip_id not found", ux_base);
     2   beizhang     err_status = UNSUCCESSFUL_EC;
     2   beizhang   }
     2   beizhang   else {
     2   beizhang 
     2   beizhang    /* interrupts might be used by UXMANA; this won't do anymore!
     2   beizhang     * there doesn't seem to be a writeable register we could
     2   beizhang     * write on both UX1 & UX30. L1BP on UX30 perhaps,
     2   beizhang     * and some unused buffer_config on UX1
     2   beizhang     *
     2   beizhang     ux_write_reg_word__r(ux_base, UX_INT_MASK_REG, 0x1000);
     2   beizhang     if ( ux_read_reg_word__r(ux_base, UX_INT_MASK_REG) != 0x1000 ) {
     2   beizhang       err_status = UNSUCCESSFUL_EC;
     2   beizhang     }
     2   beizhang     ux_write_reg_word__r(ux_base, UX_INT_MASK_REG, UX_INT_MASK_NONE);
     2   beizhang     if ( ux_read_reg_word__r(ux_base, UX_INT_MASK_REG) != UX_INT_MASK_NONE ) {
     2   beizhang       err_status = UNSUCCESSFUL_EC;
     2   beizhang 
     2   beizhang 
     2   beizhang     }
     2   beizhang     TEST_WRITE_R("UXMANA_TEST: Interrupt register read", reg_value);
     2   beizhang     */
     2   beizhang   }
     2   beizhang 
     2   beizhang   return err_status;
     2   beizhang }
     2   beizhang 
     2   beizhang 
     2   beizhang /****************************************************************************
     2   beizhang  *  FUNCTION: ux_check_reg_defaults__r
     2   beizhang  ****************************************************************************
     2   beizhang  *
     2   beizhang  *  Causes a HW reset on UX ASIC and then reads all registers making
     2   beizhang  *  sure they properly contain their power up default values.
     2   beizhang  *  However, this checking is questionable since UX ASIC datasheet 1.2
     2   beizhang  *  tells software to assume registers are in unspecified state after
     2   beizhang  *  power up... Status registers get cleared when read.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    The index of register containing invalid value or UX_POWER_UP_OK
     2   beizhang  *
     2   beizhang  ***************************************************************************/
     2   beizhang PRIVATE integer ux_check_reg_defaults__r
     2   beizhang (
     2   beizhang   dword ux_base /* base address for UX registers */
     2   beizhang )
     2   beizhang {
     2   beizhang   integer             i;            /* loop counter */
    20   beizhang   integer             buff_reg_start;
     2   beizhang   integer             reg_offset;   /* which register we're using ? */
     2   beizhang 
     2   beizhang   /*
     2   beizhang    *  Perform HW reset. Not part of the functionality of UX ASIC registers.
     2   beizhang    *  Vital here since startup logicl leaves UX ASICs in reset state.
     2   beizhang    */
    35   beizhang  /* if ((g_my_piu_type!= PIU_TYPE_T_CCP1D_A_C)&&(g_my_piu_type != PIU_TYPE_T_CCP1D_B_C)) */
    35   beizhang   if(is_asic__r(g_ux1_base_addr))
    20   beizhang   {
    20   beizhang       ux_write_reg_byte__r(ux_base, UX_HW_RESET_REG, UX_HW_RESET_ON);
    20   beizhang       delay(1);  /* hold in reset for 10 ms */
    20   beizhang       ux_write_reg_byte__r(ux_base, UX_HW_RESET_REG, UX_HW_RESET_OFF);
    20   beizhang       delay(1);
    20   beizhang   }
     2   beizhang   /* chip ID */
     2   beizhang   if ((ux_read_reg_word__r (ux_base, UX_CHIP_ID_REG) &
     2   beizhang        0xFFFF) != UX_CHIP_ID) {
     2   beizhang     return UX_CHIP_ID_REG;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* chip version not specified in data sheet 1.2 */
     2   beizhang   /* buffer configuration */
     2   beizhang   for (i = 0; i <= 0x1E; i++) {
     2   beizhang     reg_offset = BUFF_CONFIG_OFFSET(i);
     2   beizhang     if ((ux_read_reg_word__r(ux_base, reg_offset) &
     2   beizhang         UX_MASK_BUFF_CONFIG) != UX_INIT_BUFF_CONFIG) {
     2   beizhang       return reg_offset;
     2   beizhang     }
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* utopia configuration */
     2   beizhang   if ((ux_read_reg_word__r (ux_base, UX_UTOPIA_CONFIG_REG) &
     2   beizhang        UX_MASK_UTOPIA_CONFIG) != UX_INIT_UTOPIA_CONFIG) {
     2   beizhang     return UX_UTOPIA_CONFIG_REG;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* L1 buffer pointer */
     2   beizhang   if ((ux_read_reg_word__r(ux_base, UX_L1_BP_REG) &
     2   beizhang       UX_MASK_L1_BP) != UX_INIT_L1_BP) {
     2   beizhang     return UX_L1_BP_REG;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* port enable */
     2   beizhang   if ((ux_read_reg_word__r(ux_base, UX_PORT_ENABLE_REG) &
     2   beizhang       UX_MASK_PORT_ENABLE) != UX_INIT_PORT_ENABLE) {
     2   beizhang     return UX_PORT_ENABLE_REG;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* port power */
     2   beizhang   if ((ux_read_reg_word__r(ux_base, UX_PORT_POWER_REG) &
     2   beizhang       UX_MASK_PORT_POWER) != UX_INIT_PORT_POWER) {
     2   beizhang     return UX_PORT_POWER_REG;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* diagnostics */
     2   beizhang   if ((ux_read_reg_byte__r(ux_base, UX_DIAG_REG) &
     2   beizhang       UX_MASK_DIAG) != UX_INIT_DIAG) {
     2   beizhang     return UX_DIAG_REG;
     2   beizhang   }
     2   beizhang   /* soft reset is write only */
     2   beizhang   /* PLL_BW needs to be initialized, power up value unknown */
     2   beizhang   /*
     2   beizhang    * read the 5 transmit cell counters AND the 5 receive cell counters
     2   beizhang    * which will clear the values to zero, ignore the power up value
     2   beizhang    */
     2   beizhang   for (reg_offset = 0x50; reg_offset <= 0x62; reg_offset += 2) {
     2   beizhang     ux_read_reg_word__r(ux_base, reg_offset);
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* read the INTERRUPT register just to clear out the power up value */
     2   beizhang   ux_read_reg_word__r(ux_base, UX_INTERRUPT_REG);
     2   beizhang 
     2   beizhang   /* interrupt mask */
     2   beizhang   if ((ux_read_reg_word__r(ux_base, UX_INT_MASK_REG) &
     2   beizhang       UX_MASK_INT_MASK) != UX_INIT_INT_MASK) {
     2   beizhang     return UX_INT_MASK_REG;
     2   beizhang   }
     2   beizhang 
     2   beizhang   TEST_WRITE__R("UXDLIB: registers ok", ux_base);
     2   beizhang   return UX_POWER_UP_OK;
     2   beizhang }
     7   beizhang PRIVATE error_t ux_hw_init__r(dword base_addr)
     2   beizhang {
     7   beizhang     integer  reg_status;
    20   beizhang     error_t ec;
    35   beizhang 	
    35   beizhang     if (!g_fpga_loaded) {
    35   beizhang 	 g_fpga_loaded = is_fpga_loaded__r(g_ux1_base_addr);
    35   beizhang 	 if(!g_fpga_loaded){
    35   beizhang 	 	printc("UX HW init failed because fpga NOT loaded yet ! ");
    35   beizhang 	 	return UNSUCCESSFUL_EC;
    35   beizhang 	 }
    20   beizhang         if( SUCCESS_EC != (ec = update_conf_variables__r())){
    20   beizhang 	    printc("update conf variables failed for CCP1D %x",ec);		
    20   beizhang             return ec;}
    35   beizhang    }
    35   beizhang 	
    35   beizhang   /* if ((g_my_piu_type!= PIU_TYPE_T_CCP1D_A_C)&&(g_my_piu_type != PIU_TYPE_T_CCP1D_B_C)) */
    35   beizhang    reg_status = ux_check_reg_defaults__r(base_addr);
    35   beizhang    /*else
    35   beizhang    	reg_status = UX_POWER_UP_OK;*/
    35   beizhang    if (reg_status == UX_POWER_UP_OK) {
     7   beizhang         ux_write_reg_word__r(base_addr,UX_PLL_BW_REG, UX_PLL_BW_INIT);
    35   beizhang 		
    27   beizhang 	 if ((g_my_piu_type== PIU_TYPE_T_CCP1D_A_C)||(g_my_piu_type == PIU_TYPE_T_CCP1D_B_C)) 
    27   beizhang 	  	ux_write_reg_word__r(base_addr,UX_UTOPIA_CONFIG_REG, UX_UTOPIA_CONF_UX21);
    27   beizhang 	 else
    27   beizhang               ux_write_reg_word__r(base_addr,UX_UTOPIA_CONFIG_REG, UX_UTOPIA_CONF_UX1);
    35   beizhang 	 
     7   beizhang         ux_write_reg_byte__r(base_addr,UX_SOFT_RESET_REG, UX_SR);          /* Reset the chip */
     7   beizhang         ux_write_reg_word__r(base_addr,UX_INT_MASK_REG, UX_INT_MASK_ALL);  /* enable all interrupts except cell discard */
     7   beizhang         ux_write_reg_word__r(base_addr,UX_PORT_POWER_REG, UX_PORT_POWER_ALL);
     7   beizhang         ux_write_reg_word__r(base_addr,UX_PORT_ENABLE_REG, UX_PORT_ENABLE_ALL);
    35   beizhang         ux_write_reg_word__r(base_addr,UX_DIAG_REG,0x00);/*reset loopback setting*/
    27   beizhang         /*ux_write_reg_word__r(base_addr,UX_SCRAM_REG,0x00);*/
     7   beizhang         return SUCCESS_EC;
     7   beizhang     }else{
    21   beizhang         LOG_WRITE__R("UXDLIB: Invalid register value after reset %x", reg_status);
     7   beizhang         return UNSUCCESSFUL_EC;
     7   beizhang    }
     2   beizhang }
     2   beizhang /****************************************************************************
     2   beizhang  *  FUNCTION: ux_read_reg_byte__r
     2   beizhang  ****************************************************************************
     2   beizhang  *
     2   beizhang  *  Reads an 8-bit register on UX ASIC.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    Contents of register
     2   beizhang  *
     2   beizhang  ***************************************************************************/
     2   beizhang PRIVATE void install_interrupt_handlers__r(void)
     2   beizhang {
     2   beizhang   int_serv_type_t serv_type = INT_SERV_TYPE_T_SIGNAL_BIT + INT_SERV_TYPE_T_ENABLE_BIT;
    20   beizhang   hw_int_level_t hw_int_level;
     2   beizhang 
     7   beizhang   switch (g_my_piu_type)
     2   beizhang   {
     2   beizhang   case PIU_TYPE_T_CCPC2_C:
     2   beizhang     hw_int_level = get_int_level_r(CCPC2_INT_ID_UX1);
     2   beizhang     set_int_type_r(hw_int_level, HW_INT_TYPE_T_NO_PRIOR_C + HW_INT_TYPE_T_FALLING_EDGE_C);
     2   beizhang     install_int_service_r(hw_int_level, serv_type, NULL, UXMANA_INT1_SEM);
     2   beizhang     break;
     2   beizhang 
     2   beizhang   case PIU_TYPE_T_CCPC2_A_C:
     2   beizhang     hw_int_level = get_int_level_r(CCPC2_INT_ID_UX1);
     2   beizhang     set_int_type_r(hw_int_level, HW_INT_TYPE_T_NO_PRIOR_C + HW_INT_TYPE_T_FALLING_EDGE_C);
     2   beizhang     install_int_service_r(hw_int_level, serv_type, NULL, UXMANA_INT1_SEM);
     2   beizhang     break;
     2   beizhang 
     2   beizhang   case PIU_TYPE_T_CCP10_C:
     2   beizhang     hw_int_level = get_int_level_r(CCPC2_INT_ID_UX1);
     2   beizhang     set_int_type_r(hw_int_level, HW_INT_TYPE_T_NO_PRIOR_C + HW_INT_TYPE_T_FALLING_EDGE_C);
     2   beizhang     install_int_service_r(hw_int_level, serv_type, NULL, UXMANA_INT1_SEM);
     2   beizhang     break;
     2   beizhang 
     2   beizhang   case PIU_TYPE_T_CCP18_A_C:
     2   beizhang   case PIU_TYPE_T_CCP18_B_C:
     2   beizhang   case PIU_TYPE_T_CCP18_C_C:
     2   beizhang     hw_int_level = get_int_level_r(CCP18_INT_ID_UX1);
     2   beizhang     set_int_type_r(hw_int_level, HW_INT_TYPE_T_NO_PRIOR_C + HW_INT_TYPE_T_FALLING_EDGE_C);
     2   beizhang     install_int_service_r(hw_int_level, serv_type, NULL, UXMANA_INT1_SEM);
     2   beizhang     break;
    20   beizhang    case PIU_TYPE_T_CCP1D_A_C:
    13   beizhang   case PIU_TYPE_T_CCP1D_B_C:
    13   beizhang     hw_int_level = get_int_level_r(CCP1D_INT_ID_UX1);
    15   beizhang     if(hw_int_level == HW_INT_LEVEL_T_ILLEGAL_C){
    14   beizhang         printc("Illegal hw interrupt level is returned. %x ", hw_int_level);
    14   beizhang 	 return;
    14   beizhang     }
    13   beizhang     set_int_type_r(hw_int_level, HW_INT_TYPE_T_NO_PRIOR_C + HW_INT_TYPE_T_FALLING_EDGE_C);
    13   beizhang     install_int_service_r(hw_int_level, serv_type, NULL, UXMANA_INT1_SEM);
    13   beizhang     break;
     2   beizhang   default:
     2   beizhang     install_int_service_r(UC_INT_LVL_UX1, serv_type, NULL, UXMANA_INT1_SEM);
     2   beizhang     break;
     2   beizhang   }
     2   beizhang }
     2   beizhang 
     7   beizhang PRIVATE error_t  ux_conf_loopback__r(
     7   beizhang     byte        p_port_index,
     7   beizhang     bool        p_enable)
     7   beizhang {
     7   beizhang     dword   base_addr;
     7   beizhang     byte      reg_value;
     7   beizhang     error_t  status = SUCCESS_EC;
     7   beizhang     if(p_port_index>= UX_SERIAL_PORT_CNT__C || p_port_index<0)
     7   beizhang         return PARAM_NUMBER_DOES_NOT_EXIST_EC;
     7   beizhang     status       = ux_get_pci_base_addr__r(&base_addr,g_my_piu_type);
     7   beizhang     if(status != SUCCESS_EC) return status;
     2   beizhang 
     7   beizhang     if(p_enable)
     7   beizhang         reg_value =  1<<p_port_index;
     7   beizhang     else
     7   beizhang     {
     7   beizhang         reg_value = ux_read_reg_byte__r(base_addr, UX_HW_LOOPBACK_REG);
     7   beizhang         reg_value = reg_value&~(1<<p_port_index);
     7   beizhang     }
     7   beizhang     ux_write_reg_byte__r(base_addr,UX_HW_LOOPBACK_REG,reg_value);
     7   beizhang     return status;
     7   beizhang }
     7   beizhang /*Public implementation*/
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_init_uxdlib_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  Library initialization function. Should be called once each time the
     2   beizhang  *  library has been created, before using any provided services.
     2   beizhang  *
     2   beizhang  *  1. Initializes global variables such as own plug-in unit type, library
     2   beizhang  *     initialization status, UX ASIC base_addresses.
     2   beizhang  *  2. Checks whether UX ASIC has already been initialized and if so, updates
     2   beizhang  *     configured ports and Utopia addresses.
     2   beizhang  *  3. Checks whether given reference was valid.
     2   beizhang  *  4. Delivers PIU classification based on presence of UX1.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   -
     2   beizhang  *    OUT:  Plug-in unit classification based on presence of HW block UX1.
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - library init ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - the passed data structure reference was null
     2   beizhang  *    UX_INVALID_OPERATION_EC   - library not supported on this PIU
     2   beizhang  *    error codes returned by PBMLIB or RAUDAT
     2   beizhang  *
     2   beizhang  *    Handling of PIU types MX622, MX622 A, NI4S1 A, SF05 and SF05 A
     2   beizhang  *    removed in A3 (T.Turunen Dec 2000)
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_init_uxdlib_r_lib
     2   beizhang (
     2   beizhang   ux_hw_block_type_t     *own_unit
     2   beizhang )
     2   beizhang {
     7   beizhang     piu_type_info_t     piu_type_info;
     7   beizhang     error_t             ec;
     2   beizhang 
     7   beizhang     TEST_WRITE__R("UXDLIB: Test log writings & debug mode", g_lib_initialized);
     7   beizhang     if ( g_lib_initialized ) {
     7   beizhang         TEST_WRITE__R("UXDLIB: Library already initialized", g_lib_initialized);
     7   beizhang     }
     7   beizhang     if ( !do_enter__r() ) {
     7   beizhang         return TIMEOUT_ERROR_EC;
     7   beizhang     }
     7   beizhang     if ( NULL == own_unit ) {
     2   beizhang         do_exit__r();
     7   beizhang         TEST_WRITE__R("UXDLIB: null pointer passed as own_unit ", own_unit);
     7   beizhang         return UX_INVALID_PARAMETER_EC;
     7   beizhang     }
     7   beizhang     if ( SUCCESS_EC == (ec = own_piu_type_info_r(&piu_type_info)) ) {
     7   beizhang         g_my_piu_type = piu_type_info.piu_type;
     7   beizhang         ec = ux_get_pci_base_addr__r(&g_ux1_base_addr,g_my_piu_type);
    35   beizhang 	 if(ec!=SUCCESS_EC) return ec; 
     7   beizhang         g_ux_block_type = UX_HW_BLOCK_TYPE_T_TRIB;
     7   beizhang         *own_unit = g_ux_block_type;
    10   beizhang     }
    10   beizhang 
    10   beizhang     if (ec != SUCCESS_EC)
    10   beizhang     {
    10   beizhang         LOG_WRITE__R("UXDLIB: Unable to specify PIU type or get base address failed", ec);
     2   beizhang         do_exit__r();
     2   beizhang         return ec;
     7   beizhang     }
    35   beizhang 	
     7   beizhang     install_interrupt_handlers__r();
     7   beizhang     /* Release chips from reset and check if they have already been
     7   beizhang      configured. If so, update library configuration variables */
    35   beizhang 
    35   beizhang     g_fpga_loaded = is_fpga_loaded__r(g_ux1_base_addr); /* if ((g_my_piu_type!= PIU_TYPE_T_CCP1D_A_C)&&
    35   beizhang 		(g_my_piu_type != PIU_TYPE_T_CCP1D_B_C))*/
    35   beizhang     if(g_fpga_loaded){
    20   beizhang 	 if( SUCCESS_EC != (ec = update_conf_variables__r()))
    20   beizhang 	 {
    20   beizhang             do_exit__r();
    20   beizhang             printc("UXDLIB: updating lib state failed status %x, piu %x\n", ec, g_my_piu_type);
    20   beizhang             return ec;
    35   beizhang 	 	}
    20   beizhang   }
    20   beizhang    g_lib_initialized = T;
     7   beizhang    do_exit__r();
     7   beizhang    return SUCCESS_EC;
     2   beizhang } /* end ux_init_uxdlib_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_init_hw_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *
     2   beizhang  *  1. Performs a hardware reset on UX ASICs in hardware blocks UX1 and UX30
     2   beizhang  *     checks for power up register defaults.
     2   beizhang  *  2. Initializes th Utopia bus and PLL bandwith and masks interrupts.
     2   beizhang  *     Currently all serial ports get powered & enabled.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   -
     2   beizhang  *    OUT:  -
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - UX1 and UX30 harware block initialization ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UNSUCCESSFUL_EC           - register defaults check failed
     2   beizhang  *
     2   beizhang  *
     2   beizhang  *  UX30 is not available in A3 (T.Turunen Dec 2000)
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_init_hw_r_lib
    20   beizhang ()
     2   beizhang {
     7   beizhang   error_t             status;
     2   beizhang   byte                chip_ind;
    20   beizhang   
     7   beizhang   CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     7   beizhang   if (g_hw_initialized) {
     2   beizhang     do_exit__r();
     2   beizhang     return  SUCCESS_EC;
     2   beizhang   }
     7   beizhang   status = ux_hw_init__r(g_ux1_base_addr);
    21   beizhang   if(status = SUCCESS_EC)
    21   beizhang   	g_hw_initialized = T;
     2   beizhang   do_exit__r();
     7   beizhang   return status;
     2   beizhang } /* end ux_init_hw_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_test_hw_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  Diagnostics service to test for valid operation of hardware blocks UX1 and
     2   beizhang  *  UX30. This routine can be called periodically in order to detect any event
     2   beizhang  *  hazardous to the hardware. The test consist of simple register read and
     2   beizhang  *  write operations.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   -
     2   beizhang  *    OUT:  -
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - register based test opearation ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UNSUCCESSFUL_EC           - register based test opearation failed
     2   beizhang  *
     2   beizhang  *  UX30 is not available in A3 (T.Turunen Dec 2000)
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_test_hw_r_lib
     2   beizhang (
     2   beizhang )
     2   beizhang {
     2   beizhang   error_t             ec;
     2   beizhang   byte                chip_ind;
     2   beizhang 
     7   beizhang   CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     2   beizhang   /* test UX1 hardware block */
     7   beizhang   ec = ux_test_chip_hw__r(g_ux1_base_addr);
     2   beizhang 
     2   beizhang   do_exit__r();
     2   beizhang   return ec;
     2   beizhang } /* end ux_test_hw_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_conf_ux1_port_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  This routine configures specified Utopia address on a given serial port on
     2   beizhang  *  hardware block UX1. Utopia addresses of Utopia Extender port in UX1 and a
     2   beizhang  *  corresponding port in UX30 should be the same. If some Utopia Extender port
     2   beizhang  *  in UX1 has already been configured with the passed Utopia address, this port
     2   beizhang  *  will be disabled first. If the given Utopia Extender port has already been
     2   beizhang  *  configured with a different Utopia address, the address will be replaced by
     2   beizhang  *  the given one. If the specified port has already been configured with the
     2   beizhang  *  specified Utopia address, the hardware won't be reconfigured.
     2   beizhang  *
     2   beizhang  *  On functional unit NIS1 this operation also configures hardware block UX1_A
     2   beizhang  *  accordingly. UX1_A has only one Utopia Extender port.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   Utopia Extender port index
     2   beizhang  *          Utopia address to be bind to this port
     2   beizhang  *    OUT:  -
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - port configuration ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - some parameter was out of range
     2   beizhang  *
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_conf_ux1_port_r_lib
     2   beizhang (
     2   beizhang  byte                   port_index,
     2   beizhang  mphy_port_number_t     utopia_address
     2   beizhang )
     2   beizhang {
     7   beizhang    if ( !do_enter__r() ) {
     2   beizhang     return TIMEOUT_ERROR_EC;
     2   beizhang   }
     7   beizhang   if ( !g_lib_initialized ) {
     2   beizhang     do_exit__r();
     7   beizhang     TEST_WRITE__R("UXDLIB: not initialized", g_lib_initialized);
     2   beizhang     return UX_LIB_NOT_INITIALIZED_EC;
     2   beizhang   }
     2   beizhang 
     7   beizhang   if ( utopia_address >= UX_BUFFER_MAX__C || port_index >= UX_SERIAL_PORT_CNT__C ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: invalid parameter", port_index);
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* On NI4S1 A we could also check whether port_index != 0, which is the
     2   beizhang      only one allowed. Only port 0 is connected on board... */
     2   beizhang 
     2   beizhang   /* The port has already been configured as wished, don't reconfigure */
     7   beizhang   if ( g_ux1_port == port_index && g_ux1_addr == utopia_address ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: UX1 port already configured", port_index);
     2   beizhang     return SUCCESS_EC;
     2   beizhang   }
     2   beizhang 
    35   beizhang   ux_conf_ux1_port__r(port_index, utopia_address);
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     7   beizhang } /* end ux_conf_g_ux1_port_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_remove_ux1_port_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  This routine disables given configured Utopia Extender port. The port can
     2   beizhang  *  be specified by either a Utopia address or a port index. If the given
     2   beizhang  *  Utopia address has a specified value (i.e. other than
     2   beizhang  *  mphy_port_number_t_unspec_c) it will be used a search key. Otherwise
     2   beizhang  *  Utopia Extender port index acts the search key. If a port is found, it will
     2   beizhang  *  disabled.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   Utopia Extender port index
     2   beizhang  *          Utopia address to be bind to this port
     2   beizhang  *    OUT:  -
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - register based test opearation ok or the
     2   beizhang  *                                port to be removed is already disabled.
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - some parameter was out of range
     2   beizhang  *
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_remove_ux1_port_r_lib
     2   beizhang (
     2   beizhang  byte                   port_index,
     2   beizhang  mphy_port_number_t     *utopia_address
     2   beizhang )
     2   beizhang {
     7   beizhang   CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     2   beizhang 
     2   beizhang   if ( utopia_address == NULL ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: null pointer passed as mphy_addr", utopia_address);
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* search by Utopia address */
     2   beizhang   if ( *utopia_address < UX_BUFFER_MAX__C ) {
     7   beizhang     if ( g_ux1_addr == *utopia_address ) {
     7   beizhang       ux_write_reg_word__r(g_ux1_base_addr, BUFF_CONFIG_OFFSET(g_ux1_addr),UX_INIT_BUFF_CONFIG); /* disable buffer */
     7   beizhang       g_ux1_addr = MPHY_PORT_NUMBER_T_UNSPEC_C;
     7   beizhang       g_ux1_port = UX_PORT_DISABLED__C;
     2   beizhang     }
     2   beizhang     else { /* The port to be removed is already disabled */
     2   beizhang       do_exit__r();
     2   beizhang       return SUCCESS_EC;
     2   beizhang     }
     7   beizhang   }/* search by port index */else {
     2   beizhang     if ( port_index >= UX_SERIAL_PORT_CNT__C ) {
     2   beizhang       do_exit__r();
     2   beizhang       TEST_WRITE__R("UXDLIB: invalid port index", port_index);
     2   beizhang       return UX_INVALID_PARAMETER_EC;
     2   beizhang     }
     2   beizhang 
     7   beizhang     if ( g_ux1_port ==  port_index ) {
     7   beizhang       ux_write_reg_word__r(g_ux1_base_addr, BUFF_CONFIG_OFFSET(g_ux1_addr),UX_INIT_BUFF_CONFIG); /* disable buffer */
     7   beizhang       *utopia_address = g_ux1_addr;
     7   beizhang       g_ux1_addr = MPHY_PORT_NUMBER_T_UNSPEC_C;
     7   beizhang       g_ux1_port = UX_PORT_DISABLED__C;
     2   beizhang     }
     2   beizhang     else { /* The port to be removed is already disabled */
     2   beizhang       do_exit__r();
     2   beizhang       return SUCCESS_EC;
     2   beizhang     }
     2   beizhang   }
     2   beizhang 
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     7   beizhang } /* end ux_remove_g_ux1_port_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_get_ux1_port_info_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  With this routine configuration information about some UX1 Utopia Extender
     2   beizhang  *  port can requested. This information contains the Utopia address of the
     2   beizhang  *  given port, if it has been configured. A reference to data structure where
     2   beizhang  *  port information should be stored is given as parameter.
     2   beizhang  *
     2   beizhang  *  Could perhaps be used to check whether MXU has been configured as active
     2   beizhang  *  or redundant by checking which one, port #0 or port #1 has been configured
     2   beizhang  *  on UX1. If the unit has just recieved power up reset, all ports are disabled.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   index of serial port in UX30 hardware block
     2   beizhang  *    OUT:  information about the port
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - port information request ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - the serial port index was out of range
     2   beizhang  *
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_get_ux1_port_info_r_lib
     2   beizhang (
     2   beizhang  byte                   port_index,
     2   beizhang  ux_port_info_t         *port_info
     2   beizhang )
     7   beizhang {    
     7   beizhang    CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     2   beizhang 
     7   beizhang   if ( port_info == NULL ||port_index >= UX_SERIAL_PORT_CNT__C ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: invalid parameter", port_index);
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     7   beizhang   if ( g_ux1_port == port_index ) {
     7   beizhang     port_info->mphy_addr = g_ux1_addr;
     2   beizhang     port_info->enabled = T;
     2   beizhang   }
     2   beizhang   else {
     2   beizhang     port_info->mphy_addr = MPHY_PORT_NUMBER_T_UNSPEC_C;
     2   beizhang     port_info->enabled = F;
     2   beizhang   }
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     7   beizhang } /* end ux_get_g_ux1_port_info_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_read_reg_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  Direct register read on a specific Utopia Exnteder chip in UX1 or UX30
     2   beizhang  *  hardware block.
     2   beizhang  *
     2   beizhang  *  -checks whether the library has been initialized.
     2   beizhang  *  -checks the presence of UX30 and UX1 hardware blocks (based on PIU type)
     2   beizhang  *  -checks the parameters ranges (chip_ind and reg_index)
     2   beizhang  *   chip_ind #0 refers to UX1 and >#0 the chips of UX30.
     2   beizhang  *   UX1_A chip on NI4S1_A is chip_ind #1.
     2   beizhang  *  -checks whether this register is write only
     2   beizhang  *  -checks whether the target is an 8-bit register and if so, only read the
     2   beizhang  *   lower byte
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   chip index,
     2   beizhang  *          register index
     2   beizhang  *    OUT:  register contents
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - register read ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - the given parameters were out of range
     2   beizhang  *    UX_INVALID_OPERATION_EC   - the target register was write only
     2   beizhang  *
     2   beizhang  *  UX30 is not available in A3 (T.Turunen Dec 2000)
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_read_reg_r_lib
     2   beizhang (
     2   beizhang  byte                   chip_ind,
     2   beizhang  byte                   reg_index,
     2   beizhang  word                   *value
     2   beizhang )
     2   beizhang {
     2   beizhang   dword                 chip_base;
     7   beizhang   CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     7   beizhang   
     7   beizhang   chip_base = g_ux1_base_addr;    /* always in A3 (T.Turunen Dec 2000)*/
     2   beizhang 
     2   beizhang   /* check whether reg_index is out of range */
     2   beizhang   if ( reg_index > UX_REG_OFS_MAX) {
     2   beizhang     do_exit__r();
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* check whether reg_index refers to a write only register */
     2   beizhang   if ( reg_index == UX_SOFT_RESET_REG ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: write only register", reg_index);
     2   beizhang     return UX_INVALID_OPERATION_EC;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* check whether the target register is 16 or 8 bits wide */
     2   beizhang   if ( reg_index == UX_DIAG_REG ) {
     2   beizhang     TEST_WRITE__R("UXDLIB: 8-bit register", reg_index);
     2   beizhang     *value = ux_read_reg_byte__r(chip_base, reg_index);
     7   beizhang   }/* 16-bit register */
     2   beizhang   else {
     2   beizhang     if ( reg_index % 2 != 0 ) {  /* 16 bit registers start at even indexes */
     2   beizhang       do_exit__r();
     2   beizhang       TEST_WRITE__R("UXDLIB: registers start at even addresses", reg_index);
     2   beizhang       return UX_INVALID_PARAMETER_EC;
     2   beizhang     }
     2   beizhang     else {
     2   beizhang       *value = ux_read_reg_word__r(chip_base, reg_index);
     2   beizhang     }
     2   beizhang   }
     2   beizhang 
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     2   beizhang } /* end ux_read_reg_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_write_reg_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  Direct register write on a specific Utopia Exnteder chip in UX1 or UX30
     2   beizhang  *  hardware block.
     2   beizhang  *
     2   beizhang  *  library can be confused badly by writing port configuration directly
     2   beizhang  *  to hardware. Besides conflicting use of Utopia addresses might
     2   beizhang  *  happen.
     2   beizhang  *
     2   beizhang  *  -checks whether the library has been initialized
     2   beizhang  *  -checks the presence of UX30 and UX1 hardware blocks (based on PIU type)
     2   beizhang  *  -checks the parameters ranges (chip_ind and reg_index).
     2   beizhang  *   chip_ind #0 refers to UX1 and >#0 the chips of UX30
     2   beizhang  *   UX1_A chip on NI4S1_A is chip_ind #1
     2   beizhang  *  -checks whether this register is read only
     2   beizhang  *  -checks whether the target is an 8-bit register and if so, only write the
     2   beizhang  *   lower byte
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   chip index,
     2   beizhang  *          register index,
     2   beizhang  *          desired register contents
     2   beizhang  *    OUT:  -
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - register write ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - the given parameters were out of range
     2   beizhang  *    UX_INVALID_OPERATION_EC   - the target register was read only
     2   beizhang  *
     2   beizhang  *  UX30 is not available in A3 (T.Turunen Dec 2000)
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_write_reg_r_lib
     2   beizhang (
     2   beizhang  byte                   chip_ind,
     2   beizhang  byte                   reg_index,
     2   beizhang  word                   value
     2   beizhang )
     2   beizhang {
     2   beizhang   dword                 chip_base;
     7   beizhang   CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     7   beizhang  
     7   beizhang   chip_base = g_ux1_base_addr;    /*always in A3 (T.Turunen Dec 2000)*/
     2   beizhang 
     2   beizhang   /* Check whether reg_indexis an unused register that denotes HW reset here.
     2   beizhang      For this purpose it would be nice reg_index was integer...
     2   beizhang      I guess this is an undocumented feature.                         */
     2   beizhang   if ( reg_index == HW_RESET_REG_IND ) {
     2   beizhang     ux_write_reg_byte__r(chip_base, UX_HW_RESET_REG, UX_HW_RESET_ON);
     2   beizhang     delay(1);  /* hold in reset for 10 ms */
     2   beizhang     ux_write_reg_byte__r(chip_base, UX_HW_RESET_REG, UX_HW_RESET_OFF);
     2   beizhang     delay(1);
     2   beizhang     do_exit__r();
     2   beizhang     return SUCCESS_EC;
     2   beizhang   }
     2   beizhang   /* check whether reg_index is out of range */
     2   beizhang   if ( reg_index > UX_REG_OFS_MAX) {
     2   beizhang     do_exit__r();
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     2   beizhang   /* check whether the target register is 16 or 8 bits wide */
     7   beizhang   if ( reg_index == UX_DIAG_REG ||reg_index == UX_SOFT_RESET_REG ) {
     2   beizhang     TEST_WRITE__R("UXDLIB: 8-bit register", reg_index);
     2   beizhang     ux_write_reg_byte__r(chip_base, reg_index, (byte)value);
     2   beizhang   }
     2   beizhang   /* 16-bit register */
     2   beizhang   else {
     2   beizhang     if ( reg_index % 2 != 0 ) {  /* 16 bit registers start at even indexes */
     2   beizhang       do_exit__r();
     2   beizhang       TEST_WRITE__R("UXDLIB: registers start at even addresses", reg_index);
     2   beizhang       return UX_INVALID_PARAMETER_EC;
     2   beizhang     }
     2   beizhang     else {
     2   beizhang       ux_write_reg_word__r(chip_base, reg_index, value);
     2   beizhang     }
     2   beizhang   }
     2   beizhang 
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     2   beizhang } /* end ux_write_reg_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_get_ux1_status_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  Retrieves current status (syncronization and cell discarding) of serial
     2   beizhang  *  ports in UX1 hardware block.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   -
     2   beizhang  *    OUT:  Current status of serial ports in UX1
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - status retrieval ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - the given data structure reference is null
     2   beizhang  *
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_get_ux1_status_r_lib
     2   beizhang (
     2   beizhang  ux_port_status_t          *ux1_status
     2   beizhang )
     2   beizhang {
     2   beizhang   byte                  chip_ind;
     2   beizhang   word                  status;
     2   beizhang 
     2   beizhang   /* perhaps syncronization is overkill here since most likely
     2   beizhang    * only one hand in one interrupt processing family will call this
     7   beizhang    */    
     7   beizhang    CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     2   beizhang 
     2   beizhang   if ( NULL == ux1_status ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: null pointer passed as ux1_status", ux1_status);
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     7   beizhang   status = ux_read_reg_word__r(g_ux1_base_addr, UX_STATUS_REG);
     2   beizhang   ux1_status->cell_discard = status & 0x1F;
     2   beizhang   ux1_status->sync_found = (status >> 5) & 0x1F;
     2   beizhang   ux1_status->sync_lost = (status >> 10) & 0x1F;
     2   beizhang 
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     2   beizhang } /* end ux_get_ux1_status_r_lib */
     2   beizhang 
     2   beizhang 
     2   beizhang /*****************************************************************************
     2   beizhang  *  FUNCTION: ux_get_ux1_int_cause_r_lib
     2   beizhang  *****************************************************************************
     2   beizhang  *
     2   beizhang  *  Retrieves interrupt cause (syncronization and cell discarding) of serial
     2   beizhang  *  ports in UX1 hardware block.
     2   beizhang  *
     2   beizhang  *  EXTERNAL VARIABLE REFERENCES:
     2   beizhang  *    IN:   -
     2   beizhang  *    OUT:  Interrupt causes of serial ports in UX1
     2   beizhang  *
     2   beizhang  *  RETURN VALUE:
     2   beizhang  *    SUCCESS_EC                - status retrieval ok
     2   beizhang  *    TIMEOUT_ERROR_EC          - protection semaphore request timed out
     2   beizhang  *    UX_LIB_NOT_INITIALIZED_EC - library data area hasn't been initialized
     2   beizhang  *    UX_INVALID_PARAMETER_EC   - the given data structure reference is null
     2   beizhang  *
     2   beizhang  *****************************************************************************/
     2   beizhang PUBLIC error_t far ux_get_ux1_int_cause_r_lib
     2   beizhang (
     2   beizhang  ux_port_status_t          *ux1_status
     2   beizhang )
     2   beizhang {
     2   beizhang   byte                  chip_ind;
     2   beizhang   word                  status;
     2   beizhang 
     2   beizhang   /* perhaps syncronization is overkill here since most likely
     2   beizhang    * only one hand in one interrupt processing family will call this
     7   beizhang    */    
     7   beizhang   CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     7   beizhang  
     2   beizhang   if ( NULL == ux1_status ) {
     2   beizhang     do_exit__r();
     2   beizhang     TEST_WRITE__R("UXDLIB: null pointer passed as ux1_status", ux1_status);
     2   beizhang     return UX_INVALID_PARAMETER_EC;
     2   beizhang   }
     2   beizhang 
     7   beizhang   status = ux_read_reg_word__r(g_ux1_base_addr, UX_INTERRUPT_REG);
     2   beizhang   ux1_status->cell_discard = status & 0x1F;
     2   beizhang   ux1_status->sync_found = (status >> 5) & 0x1F;
     2   beizhang   ux1_status->sync_lost = (status >> 10) & 0x1F;
     2   beizhang 
     2   beizhang   do_exit__r();
     2   beizhang   return SUCCESS_EC;
     2   beizhang } /* end ux_get_ux1_int_cause_r_lib */
     2   beizhang 
     7   beizhang PUBLIC error_t far ux_load_fpga_r_lib
     7   beizhang (
     7   beizhang  file_handle_t   p_file_handle,
     7   beizhang  bool               p_forced
     7   beizhang )
     7   beizhang {
     7   beizhang     error_t                status = SUCCESS_EC;
     7   beizhang     status = ux_load_fpga__r(p_file_handle,p_forced);
     7   beizhang     return status;
     7   beizhang }
     7   beizhang PUBLIC error_t far ux_conf_loopback_r_lib
     7   beizhang (
     7   beizhang     byte        p_port_index,
     7   beizhang     bool        p_enable
     7   beizhang  )
     7   beizhang {
     7   beizhang     error_t                status = SUCCESS_EC;
     7   beizhang     CHECK_UXLIB_ENTRY__R(g_lib_initialized);
     7   beizhang     status = ux_conf_loopback__r(p_port_index,p_enable);
     7   beizhang     do_exit__r();
     7   beizhang     return status;
     7   beizhang }
     7   beizhang 
     7   beizhang /*
     7   beizhang  * *
     7   beizhang  * *  Further development ideas:
     7   beizhang  * *
     7   beizhang  * *  The chip diagnostic routine is pretty dumb. Different routines for
     7   beizhang  * *  UX1 and UX30 could be done. On UX30 we could write L1_BP and
     7   beizhang  * *  on UX1 write a buff config that's not used by UX1.
     7   beizhang  * *
     7   beizhang  * *  Currently powers up & enables all serial ports on HW block initialization.
     7   beizhang  * *  Further development might be runnig power down on unused ports for
     7   beizhang  * *  power saving.
     7   beizhang  * *
     7   beizhang  * *  Currently library's view of port configuration can be confused
     7   beizhang  * *  by directly writing to BUFF_CONFIG registers. This could be fixed.
     7   beizhang  * *
     7   beizhang  */
     2   beizhang /* end uxdmaigx.c */
